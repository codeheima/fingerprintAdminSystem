
服务器：
1. 监控  ： 是否连接成功 、 校验参数是否初始化

2. 记录 zf
    tables:
	user:  user_Id + pd + name  + taiji_code + sex 
	user_zf_tmp : user_id + zf_arr
	user_zf : user_Id + zf_arr
	user_target_cmp : user_id + target_id
	user_current : user_id + ip + mac + cup + time
	login_log : user_id  + name + taiji_code + time + ip + mac + cup + action_type (上线|下线) 

	
3. 比较 zf


4.登录方式：
   1. 管理员：
   1.1 建立用户  (增删改查 |  录入指纹) (修改密码,登出)
   1.2 指纹录入页面  (添加单个指纹|合并指纹| 指纹删除)
   1.3 登录查询  (登录登出状态)
   1.4 设备监控  (是否在线)


   2. 用户:
   2.1 用户登录查询 （修改密码 ）


   3. 指纹：
   3.1 上传指纹
   验证ip + mac + cup 的操作记录:
   3.1.1 指纹比较 (验证库里是否存在)
   3.1.2 指纹入库 ()


  1.查询()  bean   , method

  2.翻译()  "ns.key"

  iterface{
		getKey();
		getCols();
		trans(List<DataObject> list);
  },

  3.导出 poi
  
  
  create Map();

  
1.注册
 1.1 zc MC  ==> new Map();
 1.2 zc CV  ==> new Map();
2.m.change()


1
2
3
4
5
6

m1
  c1
  c2
  c3 
      v31
	  v32
	  v33
	  
m2
  c11
  c12	
  c13
      v11
      v12
      v13	  
	  
m  

   cs {
    	id : c1
    	id : c2
   }
   
   
c

   vs {
	   id : v1
	   id : v2 
   }



static  map(id,obj);


m.change();


==> c.change();


v.change();

storeChange();


var invokeNext  {

	this.childMap = new $CTJ.util.Map();
	
	this.getDatas(root);
	
	this.childMap.each(function(name,val,index,datas)
	{
		val.invokeNext();
		
	});

}


var invokeNext 
  1. 数据     new Map();
  2. 获取key  getVal(key) == > obj
  3. 注册     regist(key,obj)
  4. romove   remove(key);
  5. 遍历 for   val.invokeNext();
  6. 
  
model


ajax:
1. 管理 url sendParams ,totalCount, currentPage  , pageSize , hasNext, hasPreview
2. 通知 model


var url = PageControl


post , get

1.前后逻辑是否正常
2. 

list   === >  list


invoke 


20号  没数据了


invoke



Strack


Queue
